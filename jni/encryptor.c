/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_android_utils_Encryptor */
#include <stdio.h>
#include <string.h>
#include "encryptor.h"
#include <android/log.h>
#include <stdlib.h>
#include "des/des.h"
#include "aes/aes.h"

//log打印 des.h已定义过
//#define LOG_TAG "encryptor"
//#define LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)
//#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
//#define LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)

//DES
#define EQUAL 0
#define bool int
#define false 0
#define true 1

//AES
#define MAX_LEN (2*1024*1024)
#define AES_KEY_SIZE 256
#define READ_LEN 10

//AES_IV
static unsigned char AES_IV[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
		0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
//AES_KEY
static unsigned char AES_KEY[32] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71,
		0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81, 0x1f, 0x35, 0x2c,
		0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf,
		0xf4 };

#ifndef NULL
#define NULL	(void*)
#endif

/*
 * Class:     com_android_utils_Encryptor
 * Method:    desDecrypt
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_android_utils_Encryptor_desDecrypt(
		JNIEnv *env, jobject obj, jstring jdata) {
	LOGD("native Java_com_android_utils_Encryptor_desDecrypt");
	/************反射java代码，获取加密解密key，已经判断是否为umc的代码调用*******start*******/
	jclass clazz = (*env)->GetObjectClass(env, obj);
	//反射getTest方法 获取mothodId
	jmethodID callNameMID = (*env)->GetMethodID(env, clazz, "getTest",
			"()Ljava/lang/String;");
	//调用getTest方法
	jstring jcallName = (jstring)(*env)->CallObjectMethod(env, obj,
			callNameMID);
	char* callName = (char *)(*env)->GetStringUTFChars(env, jcallName, NULL);

	//判断方式是否被调用
	if (EQUAL != strcmp(callName, "umc_auth_test")) {
		return (*env)->NewStringUTF(env, "ASDFGHJKLQWERTYUIOPZXCVBNMMNBVCX");
	}
	//反射getSignature方法 获取mothodId
	jmethodID getSigntureMID = (*env)->GetMethodID(env, clazz, "getSignature",
			"()Ljava/lang/String;");
	jstring jsignture = (jstring)(*env)->CallObjectMethod(env, obj,
			getSigntureMID);
	char* signture = (char *)(*env)->GetStringUTFChars(env, jsignture, NULL);
	/************反射java代码，获取加密解密key，已经判断是否为umc的代码调用*******end*******/

	char result[100];
	char result1[100];
	char srcData[17];
	char encKey[100];

	char datasadf[100];
	char* dataP = datasadf;
	memset(result, 0, sizeof(result));
	memset(result1, 0, sizeof(result));
	memset(srcData, 0, sizeof(srcData));
	memset(datasadf, 0, sizeof(datasadf));
	char* data = (char *)(*env)->GetStringUTFChars(env, jdata, NULL);
	strcpy(datasadf, data);
	//加密解密可以
	strcpy(encKey, signture);

	int len = strlen(dataP);
	int temp = len - 16;
	strncpy(result1, dataP, temp);
	dataP += temp;
	strcpy(srcData, dataP);

	char pusTo[100];
	memset(pusTo, 0, sizeof(pusTo));
	vTwo2One(srcData, pusTo, strlen(srcData));

	char tempresult[32];
	memset(tempresult, 0, sizeof(tempresult));
	//调用解密方法
	function_des(DECRYPT, (unsigned char*) pusTo, (unsigned char*) encKey,
			tempresult);
	strcat(result, tempresult);
	strcat(result, result1);

	if (!IsUTF8(result, strlen(result))) {
		return (*env)->NewStringUTF(env, "ASDFGHJKLQWERTYUIOPZXCVBNMMNBVCX");
	} else {
		return (*env)->NewStringUTF(env, result);
	}

}

/*
 * Class:     com_android_utils_Encryptor
 * Method:    desEncrypt
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_android_utils_Encryptor_desEncrypt(
		JNIEnv *env, jobject obj, jstring jdata) {

	LOGE("native Java_com_android_utils_Encryptor_desEncrypt ");
	jclass clazz = (*env)->GetObjectClass(env, obj);
	jmethodID callNameMID = (*env)->GetMethodID(env, clazz, "getTest",
			"()Ljava/lang/String;");
	jstring jcallName = (jstring)(*env)->CallObjectMethod(env, obj,
			callNameMID);
	char* callName = (char *)(*env)->GetStringUTFChars(env, jcallName, NULL);
	if (EQUAL != strcmp(callName, "umc_auth_test")) {
		return (*env)->NewStringUTF(env, "ASDFGHJKLQWERTYUIOPZXCVBNMMNBVCX");
	}
	jmethodID getSigntureMID = (*env)->GetMethodID(env, clazz, "getSignature",
			"()Ljava/lang/String;");
	jstring jsignture = (jstring)(*env)->CallObjectMethod(env, obj,
			getSigntureMID);
	char* signture = (char*) (*env)->GetStringUTFChars(env, jsignture,NULL);
	char result[100];
	char srcData[9];
	char encKey[100];

	char datasadf[100];
	char* dataP = datasadf;
	memset(result, 0, sizeof(result));
	memset(srcData, 0, sizeof(srcData));
	memset(datasadf, 0, sizeof(datasadf));
	char* data = (char *)(*env)->GetStringUTFChars(env, jdata, NULL);
	strcpy(datasadf, data);
	//key
	strcpy(encKey, signture);

	int len = strlen(dataP);
	if (len < 8) {
		return (*env)->NewStringUTF(env, "");
	}

	strncpy(srcData, dataP, 8);
	char tempresult[32];
	memset(tempresult, 0, sizeof(tempresult));
	function_des(ENCRYPT, (unsigned char*) srcData, (unsigned char*) encKey,
			tempresult);

	char pusTo[100];
	memset(pusTo, 0, sizeof(pusTo));
	vOne2Two(tempresult, pusTo, 8);
	int templen = strlen(srcData);
	dataP += templen;
	strcpy(result, dataP);
	strcat(result, pusTo);

	jstring jresult = (*env)->NewStringUTF(env, result);
	return jresult;

}

/*
 * Class:     com_android_utils_Encryptor
 * Method:    aesCrypt
 * Signature: ([BJI)[B
 */
JNIEXPORT jbyteArray JNICALL Java_com_android_utils_Encryptor_aesCrypt(
		JNIEnv *env, jobject obj, jbyteArray jarray, jlong jtimestamp,
		jint jmode) {
	LOGD("native Java_com_android_utils_Encryptor_aesCrypt : %d", jmode);
	//check input data
	unsigned int len = (unsigned int) ((*env)->GetArrayLength(env, jarray));
	if (len <= 0 || len >= MAX_LEN) {
return	NULL;
}

	unsigned char *data = (unsigned char*) (*env)->GetByteArrayElements(env,
			jarray, NULL);
	if (!data) {
return	NULL;
}

//计算填充长度，当为加密方式且长度不为16的整数倍时，则填充，与3DES填充类似(DESede/CBC/PKCS5Padding)
	unsigned int mode = (unsigned int) jmode;
	unsigned int rest_len = len % AES_BLOCK_SIZE;
	unsigned int padding_len = (
			(ENCRYPT == mode) ? (AES_BLOCK_SIZE - rest_len) : 0);
	unsigned int src_len = len + padding_len;

	//设置输入
	unsigned char *input = (unsigned char *) malloc(src_len);
	memset(input, 0, src_len);
	memcpy(input, data, len);
	if (padding_len > 0) {
		memset(input + len, (unsigned char) padding_len, padding_len);
	}
	//data不再使用
	(*env)->ReleaseByteArrayElements(env, jarray, data, 0);

	//设置输出Buffer
	unsigned char * buff = (unsigned char*) malloc(src_len);
	if (!buff) {
		free(input);
return	NULL;
}
	memset(buff, src_len, 0);

	//set key & iv
	unsigned int key_schedule[AES_BLOCK_SIZE * 4] = { 0 }; //>=53(这里取64)
	aes_key_setup(AES_KEY, key_schedule, AES_KEY_SIZE);

	//执行加解密计算(CBC mode)
	if (mode == ENCRYPT) {
		aes_encrypt_cbc(input, src_len, buff, key_schedule, AES_KEY_SIZE,
				AES_IV);
	} else {
		aes_decrypt_cbc(input, src_len, buff, key_schedule, AES_KEY_SIZE,
				AES_IV);
	}

	//解密时计算填充长度
	if (ENCRYPT != mode) {
		unsigned char * ptr = buff;
		ptr += (src_len - 1);
		padding_len = (unsigned int) *ptr;
		if (padding_len > 0 && padding_len <= AES_BLOCK_SIZE) {
			src_len -= padding_len;
		}
ptr	= NULL;
}

//设置返回变量
	jbyteArray bytes = (*env)->NewByteArray(env, src_len);
	(*env)->SetByteArrayRegion(env, bytes, 0, src_len, (jbyte*) buff);

	//内存释放
	free(input);
	free(buff);

	return bytes;
}
/**
 * 判断数据编码格式是否为utf-8
 */bool IsUTF8(const void* pBuffer, long size) {
	bool IsUTF8 = true;
	unsigned char* start = (unsigned char*) pBuffer;
	unsigned char* end = (unsigned char*) pBuffer + size;
	while (start < end) {
		if (*start < 0x80) {
			start++;
		} else if (*start < (0xC0)) {
			IsUTF8 = false;
			break;
		} else if (*start < (0xE0)) {
			if (start >= end - 1)
				break;
			if ((start[1] & (0xC0)) != 0x80) {
				IsUTF8 = false;
				break;
			}
			start += 2;
		} else if (*start < (0xF0)) {
			if (start >= end - 2)
				break;
			if ((start[1] & (0xC0)) != 0x80 || (start[2] & (0xC0)) != 0x80) {
				IsUTF8 = false;
				break;
			}
			start += 3;
		} else {
			IsUTF8 = false;
			break;
		}
	}
	return IsUTF8;
}
